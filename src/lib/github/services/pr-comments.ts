import { createRepoClient, type GitHubClient } from '../client';

// Comment templates
const DEPLOYMENT_COMMENT_HEADER = '<!-- deployment-preview-bot -->';

export interface DeploymentStatus {
  status: 'pending' | 'building' | 'deploying' | 'success' | 'failure';
  url?: string;
  error?: string;
  startedAt: Date;
  completedAt?: Date;
}

// Generate deployment comment content
function generateDeploymentComment(
  prNumber: number,
  status: DeploymentStatus
): string {
  const { status: currentStatus, url, error, startedAt, completedAt } = status;
  
  // Status emoji
  const statusEmoji = {
    pending: 'â³',
    building: 'ðŸ”¨',
    deploying: 'ðŸš€',
    success: 'âœ…',
    failure: 'âŒ',
  }[currentStatus];

  // Progress bar
  const progressSteps = ['pending', 'building', 'deploying', 'success'];
  const currentStep = progressSteps.indexOf(currentStatus);
  const progress = progressSteps
    .map((step, index) => {
      if (currentStatus === 'failure') {
        return index <= currentStep ? 'âŒ' : 'âšª';
      }
      return index <= currentStep ? 'âœ…' : 'âšª';
    })
    .join(' ');

  // Time calculation
  const duration = completedAt
    ? `${Math.round((completedAt.getTime() - startedAt.getTime()) / 1000)}s`
    : 'In progress...';

  // Build comment
  let comment = `${DEPLOYMENT_COMMENT_HEADER}
## ${statusEmoji} Deployment Preview

**Status:** ${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)}
**Progress:** ${progress}
**Duration:** ${duration}
`;

  if (url) {
    comment += `\n### ðŸ”— Preview URL\n[${url}](${url})\n`;
  }

  if (error) {
    comment += `\n### âŒ Error Details\n\`\`\`\n${error}\n\`\`\`\n`;
  }

  comment += `\n---\n<sub>ðŸ¤– Generated by Review Apps Bot</sub>`;

  return comment;
}

// Find existing deployment comment
async function findDeploymentComment(
  client: GitHubClient,
  owner: string,
  repo: string,
  prNumber: number
): Promise<number | null> {
  try {
    const { data: comments } = await client.issues.listComments({
      owner,
      repo,
      issue_number: prNumber,
      per_page: 100,
    });

    const botComment = comments.find(comment => 
      comment.body?.includes(DEPLOYMENT_COMMENT_HEADER)
    );

    return botComment?.id || null;
  } catch (error) {
    console.error('Failed to find deployment comment:', error);
    return null;
  }
}

// Post or update deployment comment
export async function postDeploymentComment(
  owner: string,
  repo: string,
  prNumber: number,
  status: DeploymentStatus
): Promise<boolean> {
  try {
    const client = await createRepoClient(owner, repo);
    if (!client) {
      console.error('Failed to create GitHub client for repo');
      return false;
    }

    const commentBody = generateDeploymentComment(prNumber, status);
    const existingCommentId = await findDeploymentComment(client, owner, repo, prNumber);

    if (existingCommentId) {
      // Update existing comment
      await client.issues.updateComment({
        owner,
        repo,
        comment_id: existingCommentId,
        body: commentBody,
      });
      console.log(`Updated deployment comment for PR #${prNumber}`);
    } else {
      // Create new comment
      await client.issues.createComment({
        owner,
        repo,
        issue_number: prNumber,
        body: commentBody,
      });
      console.log(`Created deployment comment for PR #${prNumber}`);
    }

    return true;
  } catch (error) {
    console.error('Failed to post deployment comment:', error);
    return false;
  }
}

// Post a simple message comment
export async function postComment(
  owner: string,
  repo: string,
  prNumber: number,
  message: string
): Promise<boolean> {
  try {
    const client = await createRepoClient(owner, repo);
    if (!client) {
      console.error('Failed to create GitHub client for repo');
      return false;
    }

    await client.issues.createComment({
      owner,
      repo,
      issue_number: prNumber,
      body: message,
    });

    return true;
  } catch (error) {
    console.error('Failed to post comment:', error);
    return false;
  }
}